cmdhistory=["(list-terms)" "(map println '\#{a b c})" "(map first '([\:a \:b] [\:c \:d]))" "(clearkb true)" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '\#{cq}]\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (set (map first \\n                       (map \#(generate-implication true branching-factor (hash-set %)) cqset))))\\n             \\n             \\n             ;(first (generate-implication true branching-factor cqset)))\\n      (map \#(assert %) cqset))))" "(generate-implication-chain 2 3)" "(list-terms)" "\\n(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '\#{cq}]\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (set (map first \\n                       (map \#(generate-implication true branching-factor %) cqset))))\\n             \\n             \\n             ;(first (generate-implication true branching-factor cqset)))\\n      (map \#(assert %) cqset))))" "(clearkb true)" "(generate-implication-chain 2 3)" "(list-terms)" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '(cq)]\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (map first \\n                  (map \#(generate-implication true branching-factor %) cqset)))\\n             \\n             \\n             ;(first (generate-implication true branching-factor cqset)))\\n      (map \#(assert %) cqset))))" "(generate-implication-chain 2 3)" "(list-terms)" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '(cq)]\\n    (println cqset)\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (map first \\n                  (map \#(generate-implication true branching-factor %) cqset)))\\n             \\n             \\n             ;(first (generate-implication true branching-factor cqset)))\\n      (map \#(assert %) cqset))))" "(clearkb true)" "(generate-implication-chain 2 3)" "(ns csneps.test.benchmark\\n  (\:require [csneps.core.contexts \:as ct]\\n            [csneps.core.caseframes \:as cf]\\n            [csneps.core.relations \:as slot]\\n            [csneps.core \:as csneps]\\n            [csneps.core.build \:as build]\\n            [csneps.snip \:as snip]\\n            [clojure.set \:as set])\\n  (\:use [csneps.core.snuser]))" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '(cq)]\\n    (println cqset)\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (apply set/union\\n                    (map first \\n                         (map \#(generate-implication true branching-factor %) cqset))))\\n             \\n             \\n             ;(first (generate-implication true branching-factor cqset)))\\n      (map \#(assert %) cqset))))" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '(cq)]\\n    (println cqset)\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (apply clojure.set/union\\n                    (map first \\n                         (map \#(generate-implication true branching-factor %) cqset))))\\n             \\n             \\n             ;(first (generate-implication true branching-factor cqset)))\\n      (map \#(assert %) cqset))))" "(generate-implication-chain 2 3)" "(list-terms)" "(clearkb true)" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '\#{cq}]\\n    (println cqset)\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (apply clojure.set/union\\n                    (map first \\n                         (map \#(generate-implication true branching-factor %) cqset))))\\n      (map \#(assert %) cqset))))" "(generate-implication-chain 2 3)" "(list-terms)" "(snip/backward-infer (find-term 'cq))" "(list-terms)" "(clearkb true)" "(generate-implication-chain 5 100)" "(+ 1 2)" "(defn benchmark-impl\\n  (generate-implication-chain 5 100)\\n  (snip/backward-infer 'cq))" "(defn benchmark-impl\\n  []\\n  (generate-implication-chain 5 100)\\n  (snip/backward-infer 'cq))" "(benchmark-impl)" "(defn benchmark-impl\\n  []\\n  (generate-implication-chain 5 5)\\n  (snip/backward-infer 'cq))" "(benchmark-impl)" "(clearkb true)" "(benchmark-impl)" ";; Switching to csneps.test.benchmark namespace" "(benchmark-impl)" "*ns*" "(benchmark-impl)" "(list-terms)" "(snuser/list-terms)" "(clearkb true)" "(snuser/clearkb true)" "(generate-implication-chain 2 5)" "(list-terms)" "(snuser/list-terms)" "(snip/backward-infer (snuser/find-term 'cq))" "(snuser/list-terms)" "(clearkb true)" "(snuser/clearkb true)" "(defn benchmark-impl\\n  []\\n  (snuser/clearkb true)\\n  (generate-implication-chain 2 10)\\n  (snip/backward-infer (snuser/find-term 'cq)))" "(benchmark-impl)" "(list-terms)" "(ct/asserted? 'cq (ct/currentContext))" "(ct/asserted? (snuser/find-term 'cq) (ct/currentContext))" "(defn benchmark-impl\\n  []\\n  (snuser/clearkb true)\\n  (generate-implication-chain 2 5)\\n  (snip/backward-infer (snuser/find-term 'cq)))" "(benchmark-impl)" "(snuser/list-terms)" "(clearkb true)" "(defn generate-implication-chain\\n  [branching-factor maxdepth]\\n  (loop [depth 0\\n         cqset '\#{cq}]\\n    (if (< depth maxdepth)\\n      (recur (inc depth)\\n             (apply clojure.set/union\\n                    (map first \\n                         (map \#(generate-implication true branching-factor %) cqset))))\\n      (doall (map \#(snuser/assert %) cqset)))))" "(benchmark-impl)" "(snuser/list-terms)" "(benchmark-impl)" ";; Switching to csneps.test.benchmark namespace" "(benchmark-impl)" "(@csneps/TERMS 'cq)" "(benchmark-impl)" "(remove-watch csneps/TERMS \:terms)" "(benchmark-impl)" "(snuser/clearkb true)" "(+ 1 2)" ";; Switching to csneps.test.benchmark namespace" "(benchmark-impl)" "(\:hyps (ct/currentContext))" "(\:ders (ct/currentContext))" "(benchmark-impl)" "(time))" "(time)" "(benchmark-impl)" "(remove-watch (\:ders (ct/currentContext)) \:ders)" "start-time" "(benchmark-impl)" "(print-elapsed)" "(benchmark-impl)" "(.getCorePoolSize snip/executorService)" "(benchmark-impl)" "(benchmark)" "snip/queue" "snip/executorService" "(benchmark)" ";; Switching to csneps.test.benchmark namespace" "(benchmark)" "(in-ns 'csneps.snip)" "(clearkb true)" "(in-ns 'csneps.snuser)" "(clearkb true)" "(in-ns 'csneps.core.snuser)" "(clearkb true)" "(assert '(if \#{a b c} d))" "(assert '(if \#{e f} c))" "(assert 'e)" "(snip/backward-infer 'd)" "(snip/backward-infer (find-term 'd))" "(list-terms)" "(snip/backward-infer (find-term 'd))" "(assert 'e)" "(\:i-chanenls (find-term 'd))" "(\:i-chanenls (find-term 'e))" "(find-term 'e)" "(\:y-channels (find-term 'e))" "(\:i-channels (find-term 'e))" "(snip/cancel-infer (find-term 'd))" "(clearkb true)" "(assert '(if \#{a b c} d))" "(assert '(if \#{e f} c))" "(snip/backward-infer (find-term 'd))" "(list-terms)" "(assert 'e)" "(assert 'a)" "(assert 'b)" "(clearkb true)" "(benchmark)" "(csneps.test.benchmark/benchmark)" "(csneps.test.benchmark/statistics)" "(csneps.test.benchmark/benchmark)" "(clearkb true)" "(clearkb)" "(csneps.test.benchmark/benchmark)" "(csneps.test.benchmark/statistics)" "(list-terms)" "(snip/resetExecutor)" "snip/queue" "(do (assert '(if a b)) nil)" "(clearkb)" "(do (assert '(if a b)) nil)" "(list-terms)" "(clearkb true)" "(csneps.test.benchmark/benchmark)" "(snip/executorService)" "snip/executorService" "(.isTerminated snip/executorService)" "(clearkb true)" "(csneps.test.benchmark/benchmark)" "(list-terms)" "(+ 1 2)" "(csneps.test.benchmark/benchmark)" "csneps.test.benchmark/iterations" "(Thread/currentThread)" "(csneps.test.benchmark/benchmark)" "(\:i-channel (find-term 'ant8505))" "(first @csneps/TERMS)" "(\:i-channel (find-term 'ant1247594))" "(\:i-channels (find-term 'ant1247594))" "snip/nodesused" "csneps.test.benchmark/nodesused" "(fwd-inf-chain)" "(csneps.test.benchmark/fwd-inf-chain)" "(* 100 .143)" "(* 100 0.143)" "(csneps.test.benchmark/fwd-inf-chain)" "(list-terms)" "(snuser/assert\! 'ant1)" "(assert\! 'ant1)" "(list-terms)" "(\:ruis (find-term 'wft1))" "(\:i-channels (find-term 'ant1))" "(\:y-channels (find-term 'ant1))" "(\:i-channels (find-term 'ant1))" "(assert\! 'ant1)" "(unassert 'ant1)" "(assert\! 'ant1)" "(list-terms)" "(clearkb)" "(csneps.test.benchmark/fwd-inf-chain)" "(clearkb true)" "(csneps.test.benchmark/fwd-inf-chain)" "(csneps/totparam (find-term 'wft1))" "(clearkb true)" "(csneps.test.benchmark/benchmark)" "(clearkb true)" "(csneps.test.benchmark/generate-implication-chain 2 10 false)" "(writeKBToTextFile \\"/home/dan/kbtest.sneps\\")" "(map inc 1)" "(range 1 4)" "(clearkb true)" "(csneps.test.benchmark/ttasert)" "(csneps.test.benchmark/ttassert)" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(find-term 'b)" "(snip/backward-infer (find-term 'b))" "(\:support (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(\:support (find-term 'b))" "(list-terms)" "(\:support (find-term 'b))" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(\:support (find-term 'b))" "@\\n(\:support (find-term 'b))" "(first @(\:support (find-term 'b)))" "(\= (first @(\:support (find-term 'b))) (find-term 'wft1))" "(ct/asserted? (find-term 'wft1) (ct/currentContext))" "(ct/asserted? (first @(\:support (find-term 'b))) (ct/currentContext))" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(assert 'a)" "(list-terms)" "(first @(\:support (find-term 'b)))" "(first @(\:support (find-term 'wft1)))" "@(\:support (find-term 'wft1))" "(prn (find-term 'wft1))" "(map (find-term 'wft1))" "(hash-map (find-term 'wft1))" "(vals (find-term 'wft1))" "(vals (first @(\:support (find-term 'wft1))))" "(vals (first @(\:support (find-term 'b))))" "(into {} (first @(\:support (find-term 'b))))" "(into {\\n       } (find-term 'wft1))" "(\= (into {} (first @(\:support (find-term 'b)))) (into {} (find-term 'wft1)))" "(\= (first @(\:support (find-term 'b))) (find-term 'wft1))" "(type first @(\:support (find-term 'b))))" "(type (first @(\:support (find-term 'b))))" "(type (find-term 'wft1))" "(first @(\:support (find-term 'b)))" "(def t1 (ref \#{}))" "(dosync (alter t1 conj (find-term 'wft1)))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(first @(\:support (find-term 'b)))" "(clearkb true)" "(first @(\:support (find-term 'b)))" "(assert '(if a b))" "(first @(\:support (find-term 'b)))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(first @(\:support (find-term 'b)))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(first @(\:support (find-term 'b)))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(conj \#{} 'a)" "(type (conj \#{} 'a))" "(type (conj \#{'a} 'a))" "(assert '(if a b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(snip/->Message {})" "(snip/->Message)" "(snip/->Message nil 1 {} \#{} nil true false)" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "@(\:support (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "@(\:support (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "@(\:support (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "@(\:support (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(ct/asserted? 'wft1 (currentContext))" "(ct/asserted? (find-term 'wft1) (currentContext))" "(assert 'a)" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "@(\:support (find-term 'b))" "(doseq [a \#{\#{'a 'b} \#{'a 'c}}]\\n  (contains? a 'a)\\n  \\n  )" "(map (contains? % 'a) \#{\#{'a 'b} \#{'a 'c}})" "(map \#(contains? % 'a) \#{\#{'a 'b} \#{'a 'c}})" "(every? (identity true) (map \#(contains? % 'a) \#{\#{'a 'b} \#{'a 'c}}))" "(every? \#(identity true) (map \#(contains? % 'a) \#{\#{'a 'b} \#{'a 'c}}))" "(every? \#(identity true) (map (fn [x] contains? x 'a) \#{\#{'a 'b} \#{'a 'c}}))" "(every? true? (map (fn [x] contains? x 'a) \#{\#{'a 'b} \#{'a 'c}}))" "(true? true)" "(every? true? (map \#(contains? x 'a) \#{\#{'a 'b} \#{'a 'c}}))" "(every? true? (map \#(contains? % 'a) \#{\#{'a 'b} \#{'a 'c}}))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(list-terms)" "(snip/unassert (find-term 'a))" "(list-terms)" "(snip/unassert (find-term 'a))" "(list-terms)" "@(\:support (find-term 'b))" "(snip/unassert (find-term 'a))" "(list-terms)" "@(\:support (find-term 'b))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(list-terms)" "(snip/unassert (find-term 'a))" "(list-terms)" "(snip/unassert (find-term 'a))" "(list-terms)" "(\:support (find-term 'b))" "@(\:support (find-term 'b))" "(snip/unassert (find-term 'a))" "(list-terms)" "(snip/unassert (find-term 'a))" "(list-terms)" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(list-terms)" "(snip/unassert (find-term 'a))" "(list-terms)" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(list-terms)" "(\:support (find-term 'wft1))" "(every true? '())" "(every? true? '())" "(clearkb true)" "(assert 'a)" "(assert '(if a b))" "(snip/backward-infer (find-term 'b))" "(snip/unassert (find-term 'a))" "(list-terms)" "(snip/unassert (find-term 'a))" "(clearkb true)" "(assert '(if a b))" "(assert 'a)" "(snip/backward-infer (find-term 'b))" "(snip/unassert (find-term 'a))" "(list-terms)" "BinQueue" "csneps.util/BinQueue" "csneps.util/BinQueue." "(csneps.util/BinQueue. )" "(proxy [java.util.concurrent.BlockingQueue] [])" "(.add (proxy [java.util.concurrent.BlockingQueue] []) 1)" "(conj (sorted-map 1 \:a 2 \:b) 0 \:c)" "(sorted-map 1 \:a 2 \:b)" "(assoc (sorted-map 1 \:a 2 \:b) 0 \:c)" "(assoc (sorted-map 1 \:a 2 \:b) 4 \:c)" "{1 \#{}, 2 \#{}, 3 \#{}, 4 \#{}, 5 \#{},\\n                6 \#{}, 7 \#{}, 8 \#{}, 9 \#{}, 10 \#{}}" "(csneps.test.benchmark/benchmark)" "(time (conj '(a b c) 'd))" "(time (conj '[\\n              a b c] 'd))" "(defineTerm 'a)" "(clearkbb true)" "(in-ns 'snuser)" "(clearkbb true)" "(clearkb true)" "(defineTerm 'a)" "(time (assert 'a))" "(defineTerm 'b)" "(time (assert 'b))" "(time (assert 'c))" "(csneps.test.benchmark/benchmark)" "(list-terms)" "(find-term 'cq)" "(list-terms \:asserted false)" "(filter \#(not (ct/asserted? % (ct/currentContext))) @csneps/TERMS)" "(filter \#(not (ct/asserted? % (ct/currentContext))) (vals @csneps/TERMS))" "(csneps.test.benchmark/benchmark)" "(filter \#(not (ct/asserted? % (ct/currentContext))) (vals @csneps/TERMS))" "(csneps.test.benchmark/benchmark)" "(filter \#(not (ct/asserted? % (ct/currentContext))) (vals @csneps/TERMS))" "(csneps.test.benchmark/benchmark)" "(csneps.test.benchmark/ttassert)" "(csneps.test.benchmark/fwd-inf-chain)" "(dotimes [x 1000] (fwd-inf0chain))" "(dotimes [x 100] (csneps.test.benchmark/fwd-inf-chain))" "csneps.test.benchmark/totaltime" "(dotimes [x 100] (csneps.test.benchmark/fwd-inf-chain))" "csneps.test.benchmark/totaltime" "(dotimes [x 100] (csneps.test.benchmark/fwd-inf-chain))" "csneps.test.benchmark/totaltime" "(list-terms)" "csneps.test.benchmark/totaltime" "(dotimes [x 100] (csneps.test.benchmark/fwd-inf-chain))" "(benchmark)" "(csneps.test.benchmark/benchmark)" "(csneps.test.benchmark/fwd-inf-chain)" "(csneps.test.benchmark/benchmark-test fwd-inf-chain 100)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/fwd-inf-chain 100)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/tt-assert 100)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(csneps.test.benchmark/benchmark)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(list-terms)" "*ns*" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(in-ns 'csneps.core.snuser)" "(list-terms)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(list-terms)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(list-terms)" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(list-terms)" "(list-terms \:asserted true)" "(build/assert-term (find-term 'ant172))" "(build/assert-term (find-term 'ant172) (ct/currentContext) \:hyp)" "(build/assert-term (find-term 'ant172) (ct/currentContext) \:der)" "(ct/asserted? (find-term 'ant172))" "(ct/asserted? (find-term 'ant172) (ct/currentContext))" "(csneps.test.benchmark/benchmark-test csneps.test.benchmark/ttassert 100)" "(csneps.test.benchmark/benchmark)" "(interleave [\:a \:b] ['c 'f])" "(clearkb true)" "(assert '(Isa a b))" "(assert '(Isa a c))" "(assert '(Isa d c))" "(member 'a ['a 'b])" "(some \#{'a} ['a 'b])" "(list-terms)" "(build/find2 '(Isa d ?x))" "(get-term 'Isa)" "(find-term 'Isa)" "(build/find2 '(Isa d ?x))" "(build/find2 '(Isas d ?x))" "(build/find2 '(Isa d ?x))" "(build/find2 '(Isa ?y ?x))" "(build/find2 '(Isa ?y c))" "(find '(Isa ?y c))" "(assert '(every x (Isa x Animal)))" "(clearkb true)" "(assert '(every x (Isa x Animal)))" "(defn test [a & b]\\n  (println b))" "(test 'a 'b)" "(defn test [a & [b]]\\n  (println b))" "(test 'a 'b)" "(symbol? (first '(1.4)))" "(defn test2 [a] (loop [a a] (println a) (when-not (empty? a) (recur (rest a)))))" "(test2 '(a b c))" "(def abc 'a)" "(abc {'a 'b})" "(clearkb true)" "(assert '(Isa a b))" "(assert '(Isa a c))" "(find '(Isa a ?x))" "(assert '(Isa (Isa x y) z))" "(find '(Isa (Isa ?x y) z))" "(assert '(Isa a z))" "(find '(Isa (Isa ?x y) z))" "(find '(Isa (Isa ?x ?z) z))" "(find '(Isa (Isa ?x ?z) ?z))" "(assert '(Isa a a))" "(find '(Isa ?z ?z))" "(find '(Isa ?z ?v))" "(filter \#(nil? %) '(a b nil c))" "(remove \#(nil? %) '(a b nil c))" "(find '(Isa ?z ?v))" "(find '(Isa (Isa ?x ?z) ?z))" "(find '(Isa a ?x))" "(assert '(Equiv a b c))" "(find '(Equiv ?x))" "(find '(Equiv c))" "(find '(Equiv d))" "(find '(Equiv a))" "(find '(Equiv a c))" "(find '(Isa a ?x))" "(clearkb true)" "(assert '(Isa \#{Fido Lassie} \#{Dog Animal}))" "(find '(Isa ?x Animal))" "(find '(Isa ?x Turd))" "(find '(Isa ?x Dog))" "(find '(Isa ?x Animal))" "(find '(Isa ?x Dog))" "(find '(Isa ?x Animal))" "(find '(Isa ?x Dog))" "(\:down-cableset (find-term 'wft1))" "(first (\:down-cableset (find-term 'wft1)))" "(count (\:down-cableset (find-term 'wft1)))" "(find '(Isa ?x Dog))" "(find '(Isa ?x Animal))" "(find '(Isa ?x Dog))" "(assert '(Isa (Isa (Isa Clark Man) Proposition) Proposition))" "(find '(Isa (Isa x y) z) '(x y z))" "(find '(Isa (Isa x y) y) '(x y))" "(find '(Isa (Isa ?x ?y) ?y))" "(find '(Isa (Isa x y) y) '(x y))" "(find '(Isa (Isa x y) z) '(x y z))" "(clearkb true)" "(assert '(Isa (setof Fido Rover Lassie Rags) Dog))\\n(assert '(Isa (setof Fluffy Scratch) (setof Cat Mammal)))\\n(assert '(Isa (setof Frog Amphibian) Amphibian))" "(find '(Isa (setof Lassie Rags Fido Rover) Dog))" "(filter \#(> % 5) '(1 2 3 4 5 6 7))" "(set/difference \#{'a 'b} \#{'a})" "(clojure.set/difference \#{'a 'b} \#{'a})" "(drop-while \#(some \#{%} \#{'a 'b 'c}) \#{'a 'd 'c})" "(drop-while \#(some \#{%} \#{'a 'b 'c}) \#{'a 'c})" "(nil? (drop-while \#(some \#{%} \#{'a 'b 'c}) \#{'a 'c}))" "(nil? (drop-while \#(some \#{%} ('a 'b 'c)) \#{'a 'c}))" "\#(some \#{'b} ('a 'b 'c))" "(some \#{'b} ('a 'b 'c))" "(some \#{'b} '(a b c))" "(some \#{nil} '(a b c))" "(some \#{nil} '(a b c nil))" "(filter identity '(a b nil c))" "(clearkb true)" "(assert '(Isa Dog Animal))" "(find '(Isa ?x Animal))" "(map \#(zip-map % '(\:a \:b \:c)) '((1 2 3) (4 5 6)))" "(map \#(zipmap % '(\:a \:b \:c)) '((1 2 3) (4 5 6)))" "(clearkb true)" "(assert '(Isa (setof Rover Lassie) Dog))" "(find '(Isa (setof ?x ?y) Dog))" "(find '(Isa \#{?x ?y} Dog))" "(clojure.set/difference \#{'a 'b} \#{})" "(find '(Isa \#{?x ?y} Dog))" "(find '(Isa \#{Rover ?y} Dog))" "(find '(Isa \#{?x ?y} Dog))" "(find '(Isa \#{Rover ?y} Dog))" "(seq? {\:a \:b})" "(find '(Isa \#{Rover ?y} Dog))" "(find '(Isa \#{?x ?y} Dog))" "(assert '(Isa \#{Animal Dog} Animal))" "(find '(Isa \#{?x ?y} ?x))" "(assert '(Isa x x))" "(find '(Isa ?x ?x))" "(find '(Isa \#{?x ?y} ?x))" "(assert '(Isa \#{Animal Dog} Animal))" "(find '(Isa \#{?x ?y} ?x))" "(demo \:file /home/dan/CSneps/Demo/finddemo.sneps)" "(demo \:file \\"/home/dan/CSneps/Demo/finddemo.sneps\\")" "(in-ns 'csneps.core.snuser\\n       )" "(demo \:file \\"/home/dan/CSneps/Demo/finddemo.sneps\\")" "(clearkb true)" "(assert '(Isa \#{Fido Rover Lassie} Dog))" "(find '(Isa \#{Fido Rover ?x} Dog))" "(find '(Isa \#{Fido ?x} Dog))" "(find '(Isa \#{Fido x} Dog) '(x))" "(find '(Isa setof Fido x) Dog) '(x))" "(find '(Isa (setof Fido x) Dog) '(x)" "(find '(Isa (setof Fido x) Dog) '(x))" "(clearkb true)" "(find '(Isa (setof Lassie Rags Fido Rover) Dog))" "(assert '(Isa (setof Fido Rover Lassie Rags) Dog))" "(find '(Isa (setof Lassie Rags Fido Rover) Dog))" "(find '(Isa (setof Lassie Rover Fido x) Dog) '(x))" "(find '(Isa (setof Rags  x  Rover Lassie) Dog) '(x))" "(find '(Isa (setof  x  Rover Lassie) Dog) '(x))" "(assert '(Isa (setof Fluffy Scratch) (setof Cat Mammal)))\\n(assert '(Isa (setof Frog Amphibian) Amphibian))" "(find '(Isa (setof  x  Fluffy) (setof Mammal Cat)) '(x))" "(into {\:a \:b} {\:c \:d})" "(find '(Isa (setof  x  Fluffy) (setof Mammal Cat)) '(x))" "(find '(Isa (setof y Rover Fido x) Dog) '(x y))" "(find '(Isa (setof Rags  x  z Lassie) y) '(x y z))" "(find '(Isa (setof  x  Rover Lassie) y) '(x y))" "(find '(Isa (setof  x  Fluffy) (setof Mammal y)) '(x y))" "(find '(Isa (setof Frog x) x) '(x))" "(find '(Isa (setof y x) z) '(x y z))" "(find '(Isa (setof y x) x) '(x y))" "(assert '(Isa \\n\\t  (setof (Isa Fido Dog) (Isa Fluffy Cat) \\n\\t   (Isa Frog Amphibian))\\n\\t  Proposition))" "(find '(Isa (setof (Isa Fluffy Cat) (Isa Frog Amphibian)\\n              (Isa Fido Dog)) Proposition))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  (println variables pattern))" "(withInstances (?x) of (SyntacticCategoryOf NNP ?x))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  (find pattern variables))" "(withInstances (?x) of (Isa NNP ?x))" "(assert '(Isa NNP Abc))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  (find ~pattern ~variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(find pattern variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(find ~pattern ~variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(find ~'pattern ~'variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(find ~(quote pattern) ~'variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(find (quote ~pattern) ~'variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(find '~pattern '~variables))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs (find '~pattern '~variables)]\\n     subs))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs (find '~pattern '~variables)]\\n     ~subs))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [~subs (find '~pattern '~variables)]\\n     ~subs))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [~subs (find '~pattern '~variables)]\\n     subs))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (find '~pattern '~variables)]\\n     subs\#))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map first (find '~pattern '~variables))]\\n     subs\#))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#))" "(withInstances (?x) of (Isa NNP ?x))" "(assert '(Isa NNP 'Cde))" "(assert '(Isa NNP Cde))" "(withInstances (?x) of (Isa NNP ?x))" "(for [[k v] {?x 'ABC}] v)" "(for [[k v] '{?x 'ABC}] v)" "(for [[k v] '{?x ABC}] v)" "(for [[k v] {'?x 'ABC}] v)" "(for [[k v] {'?x 'ABC '?y 'BCE}] v)" "(defn [{\:keys a} & rest] a rest)" "(defn test1 [{\:keys a} & rest] a rest)" "(defn test1 [{\:keys a} & rest] (println a rest))" "(defn test1 [{\:keys 'a} & rest] (println a rest))" "(test1 \:a 1 2 3 4)" "(defn test1 [& {\:keys a} rest] (println a rest))" "(defn test1 [& {\:keys a}] (println a rest))" "(defn test1 [{\:keys [a]} & rest] (println a rest))" "(test1 \:a 1 2 3 4)" "(defn test1 [& {\:keys [a]} rest] (println a rest))" "(defn test1 [& {\:keys [a rest]}] (println a rest))" "(test1 \:a 1 \:rest '(a b c))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map (fn [~@(keys subs\#)] ~@forms) subs\#)\\n     \\n     \\n     \\n     ))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map (fn (vec (keys subs\#)) ~@forms) subs\#)\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map (fn ~(vec (keys subs\#)) ~@forms) subs\#)\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map (fn ~(vec `(keys subs\#)) ~@forms) subs\#)\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map \#(fn ~(vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map \#(fn % ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map \#(vec %) (keys subs\#))\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(keys \#{'a 'b})" "(keys {'a 'b})" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))]\\n     subs\#\\n     (map \#(vec (keys %)) subs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(fn % ~@forms) kvecs)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(fn % ~@forms) kvecs\#)))" "(withInstances (?x) of (Isa NNP ?x))" "(map \#(fn % 'a) '([v]))" "(map \#(fn % 'a) ('[v]))" "(map \#(fn % a) ('[v]))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(list 'fn % 'a) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(list 'fn % ~@forms) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) (println ?x))" "(withInstances (?x) of (Isa NNP ?x) (println 'a))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  (println forms)\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(list 'fn % ~@forms) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) (println 'a))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(list 'fn % ~forms) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) (println 'a))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(list 'fn % '~forms) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) (println 'a))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(list 'fn % '~@forms) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) (println 'a))" "(withInstances (?x) of (Isa NNP ?x) (println ?x))" "(withInstances (?x) of (Isa NNP ?x) (withInstanecs (?y) of (Isa NNP ?y) (println ?x ?y)))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(eval (list 'fn % '~@forms)) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) (withInstanecs (?y) of (Isa NNP ?y) (println ?x ?y)))" "(withInstances (?x) of (Isa NNP ?x) (withInstances (?y) of (Isa NNP ?y) (println ?x ?y)))" "(first (withInstances (?x) of (Isa NNP ?x) (withInstances (?y) of (Isa NNP ?y) (println ?x ?y))))" "(first (first (withInstances (?x) of (Isa NNP ?x) (withInstances (?y) of (Isa NNP ?y) (println ?x ?y)))))" "(first (withInstances (?x) of (Isa NNP ?x) (println ?x ?y)))" "(first (withInstances (?x) of (Isa NNP ?x) (println ?x)))" "(first (withInstances (?x) of (Isa NNP ?x) 'a))" "(withInstances (?x) of (Isa NNP ?x) 'a)" "(first (first (withInstances (?x) of (Isa NNP ?x) 'a)))" "(eval (first (withInstances (?x) of (Isa NNP ?x) 'a)))" "((first (withInstances (?x) of (Isa NNP ?x) 'a)))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#((list 'fn % '~@forms)) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) 'a)" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#(~(list 'fn % '~@forms)) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#((eval (list 'fn % '~@forms))) kvecs\#)\\n     \\n     \\n     ;(map \#(fn (vec %) ~@forms) (keys subs\#))\\n     \\n     \\n     \\n     ))" "(withInstances (?x) of (Isa NNP ?x) 'a)" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#((eval (list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %)) subs\#) ))" "(withInstances (?x) of (Isa NNP ?x) 'a)" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     subs\#\\n     (map \#((eval (list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %) subs\#) )))" "(withInstances (?x) of (Isa NNP ?x) 'a)" "(withInstances (?x) of (Isa NNP ?x) (withInstances (?y) of (Isa NNP ?x) (println ?x ?y)))" "(withInstances (?x) of (Isa NNP ?x) ?x)" "(withInstances (?x) of (Isa NNP ?x) (withInstances (?y) of (Isa NNP ?x) (println ?x ?y)))" "(withInstances (?x) of (Isa NNP ?x) (withInstances (?y) of (Isa NNP ?y) (println ?x ?y)))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?x ?y)))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?x)))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println 'a)))" "(macroexpand-1 '(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println 'a))))" "(macroexpand '(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println 'a))))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(defn [a] (defn [b] (println a b)))" "(fn [a] \\n  (fn [b] \\n    (println a b)))" "((fn [a] \\n  (fn [b] \\n    (println a b))) 'a)" "(eval `(list 'fn '[] 'a))" "(eval `(list 'let '[] 'a))" "((eval `(list 'let '[] 'a)))" "`(eval (list 'let '[] 'a))" "`(eval ~(list 'let '[] 'a))" "(eval  `(eval ~(list 'let '[] 'a)))" "(eval  `(eval ~(list 'let [] 'a)))" "(defn defn-from [args & forms] `(fn ~args ~@args))" "(defn-from '[a b] (println a))" "(defn-from '[a b] '(println a))" "(defn defn-from [args & forms] `(fn ~args ~@forms))" "(defn-from '[a b] '(println a))" "(do (clojure.core/fn [a b] (println a)))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (do (map \#(list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %) subs\#)))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(find '(Isa ?x ?y))" "(find '(Isa NNP ?y))" "(map second (find '(Isa NNP ?y)))" "(seq {\:a \:b})" "(vec {\:a \:b})" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %) subs\#))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list 'fn %1 ~'~@forms)) %2) kvecs\# (map \#(vals %) subs\#))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %) subs\#))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list 'fn %1 '~@forms) %2) kvecs\# (map \#(vals %) subs\#)))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list (list 'fn %1 '~@forms) %2) kvecs\# (map \#(vals %) subs\#)))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list (list 'fn %1 '~@forms) %2) kvecs\# (map \#(vals %) subs\#))))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(withInstances (?x) of (Isa NNP ?x) \\n  (println ?x))" "(eval (list 'fn [x] (list 'fn [y] (println x))))" "(eval (list 'fn [x] \\n            (list 'fn [y] \\n                  (println x))))" "(eval (list 'fn '[x] \\n            (list 'fn '[y] \\n                  (println x))))" "(eval (list 'fn '[x] \\n            (list 'fn '[y] \\n                  '(println x))))" "(eval +)" "(eval + 1 2)" "(eval (+ 1 2))" "(eval '(+ 1 2))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#(list (eval (list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %) subs\#))))" "(withInstances (?x) of (Isa NNP ?x) \\n  (println ?x))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(do (withInstances (?x) of (Isa NNP ?x) \\n     (withInstances (?y) of (Isa NNP ?y) \\n       (println ?y))))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n    (do (map \#(list (eval (list 'fn %1 '~@form %2)) kvecs\# (map \#(vals %) subs\#))))))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n    (do (map \#(list (eval (list 'fn %1 '~@form %2)) kvecs\# (map \#(vals %) subs\#))))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n    (do (map \#(list (eval (list 'fn %1 '~@form %2))) kvecs\# (map \#(vals %) subs\#)))))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n    (do (map \#(list (eval (list 'fn %1 '~@forms %2))) kvecs\# (map \#(vals %) subs\#)))))" "(withInstances (?x) of (Isa NNP ?x) \\n  (withInstances (?y) of (Isa NNP ?y) \\n    (println ?y)))" "(-> {\:a {\:b 'c}} \:a \:b)" "(number? 3)" "(number? 'a)" "(every? number? 123)" "(every? number? \\"123\\")" "(number? \\"123\\")" "(try 'a 'b)" "(try (Ineger/parseInt \\"asd\\") true (catch NumberFormatException e false))" "(try (Integer/parseInt \\"asd\\") true (catch NumberFormatException e false))" "(try (Integer/parseInt \\"123\\") true (catch NumberFormatException e false))" "(def a 'a)" "(value a)" "a" "b" "(resolve a)" "(resolve b)" "(withInstances (?x ?y) of (Isa ?x ?y))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y))" "(clearkb true)" "(assert '(Isa x y))" "(assert '(Isa y z))" "(find '(Isa ?x ?y))" "(interleave '[a b] '[1 2])" "(withInstances '(?x ?y) 'of '(Isa ?x ?y))" "(eval (withInstances '(?x ?y) 'of '(Isa ?x ?y)))" "(do (withInstances '(?x ?y) 'of '(Isa ?x ?y)))" "(do (withInstances '(?x ?y) 'of '(Isa ?x ?y) true))" "`~(withInstances '(?x ?y) 'of '(Isa ?x ?y) true)" "(do (withInstances '(?x ?y) 'of '(Isa ?x ?y) true))" "(find '(Isa \:x \:y) '(\:x \:y))" "(find '(Isa ?y ?y))" "(find '(Isa ?x ?y))" "(list-terms)" "(assert '(Isa x y))" "(find '(Isa ?x ?y))" "(find '(Isa \:x \:y) '(\:x \:y))" "(replace {\:a \:b} '(\:a))" "(replace {\:a \:b} '((\:a)))" "(use 'clojure.walk)" "(prewalk-replace {\:a \:b} '((\:a)))" "(defn expand-qmvar\\n  [forms]\\n  (map \#(prewalk (fn [x] (if (re-matches \#\\"^\\\\?.*\\" x) (list 'binds x) x)) %) forms))" "(expand-qmvar '((Isa ?x ?y)))" "(expand-qmvar '(Isa ?x ?y))" "(defn expand-qmvar\\n  [forms]\\n  (map \#(prewalk (fn [x] (if (re-matches \#\\"^\\\\?.*\\" (str x)) (list 'binds x) x)) %) forms))" "(expand-qmvar '(Isa ?x ?y))" "(expand-qmvar '((Isa ?x ?y)))" "(defn expand-qmvar\\n  [forms]\\n  (map \#(postwalk (fn [x] (if (re-matches \#\\"^\\\\?.*\\" (str x)) (list 'binds x) x)) %) forms))" "(expand-qmvar '((Isa ?x ?y)))" "(do (withInstances '(?x ?y) 'of '(Isa ?x ?y)))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y))" "`(~'a)" "(withInstances '(?x ?y) 'of '(Isa ?x ?y))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) '(println ?x))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x))" "(macroexpand-1 (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(macroexpand (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(assert '(Isa x y))" "(macroexpand (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(find '(Isa ?x ?y))" "(macroexpand (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(assert '(Isa x y))" "(macroexpand (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(macroexpand-1 (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(assert '(Isa x y))" "(macroexpand-1 (withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x)))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances '(?x ?y) 'of '(Isa ?x ?y) (println ?x))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(macroexpand-1 (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(assert '(Isa x y))" "(macroexpand-1 (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(defmacro withInstances \\n  \\"Builds a form which runs find on the pattern. \\"\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         vars\# (map \#(keys %) subs\#)\\n         vals\# (map \#(vals %) subs\#)]\\n     (println subs\# vars\# vals\#)\\n     (do (map \#(list 'let (vec (interleave %1 %2)) '~@forms) vars\# vals\#))))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(defmacro withInstances \\n  \\"Builds a form which runs find on the pattern. \\"\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         vars\# (map \#(keys %) subs\#)\\n         vals\# (map \#(vals %) subs\#)]\\n     (println subs\# vars\# vals\#)\\n     (apply eval (map \#(list 'let (vec (interleave %1 %2)) '~@forms) vars\# vals\#))))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(defmacro withInstances \\n  \\"Builds a form which runs find on the pattern. \\"\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         vars\# (map \#(keys %) subs\#)\\n         vals\# (map \#(vals %) subs\#)]\\n     (println subs\# vars\# vals\#)\\n     (apply do (map \#(list 'let (vec (interleave %1 %2)) '~@forms) vars\# vals\#))))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(defmacro withInstances \\n  \\"Builds a form which runs find on the pattern. \\"\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         vars\# (map \#(keys %) subs\#)\\n         vals\# (map \#(vals %) subs\#)]\\n     (println subs\# vars\# vals\#)\\n     (map \#(list 'let (vec (interleave %1 %2)) '~@forms) vars\# vals\#)))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (withInstances (?y ?z) of (Isa ?x ?y) (println ?x))))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (withInstances (?y ?z) of (Isa ?y ?z) (println ?x))))" "(assert '(Isa x y))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (withInstances (?y ?z) of (Isa ?y ?z) (println ?x))))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#((eval (list 'fn %1 '~@forms)) %2) kvecs\# (map \#(vals %) subs\#))))" "(macroexpand (withInstances (?x ?y) of (Isa ?x ?y) (println ?x)))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n    (do (map \#(list (eval (list 'fn %1 '~@forms %2))) kvecs\# (map \#(vals %) subs\#)))))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(defmacro withInstances\\n  [variables of pattern & forms]\\n  `(let [subs\# (map second (find '~pattern '~variables))\\n         kvecs\# (map \#(vec (keys %)) subs\#)]\\n     (map \#((eval (list 'fn %1 '~@forms) %2)) kvecs\# (map \#(vals %) subs\#))))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x) (println ?y))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x) (println ?y))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x) (println ?y))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x) (println ?y))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x) (println ?y))" "(assert '(Isa x y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println ?x) (println ?y))" "(withInstances (?x ?y) of (Isa ?x ?y) (println \\"AAAH\\"  ?x) (println ?y))" "(clearkb true)" "(assert '(every x (Isa x Animal)))" "(assert '(Isa (every x (isa x Animal)) Cat))" "(assert '(Isa (every x (Isa x Animal)) Cat))" "(assert '(Isa (every x) animal))" "(clearkb true)" "(assert (?x (Isa ?x Apple)))" "(assert '\\n         (?x (Isa ?x Apple)))" "(assert '(?x (Isa ?x Apple)))" "(list-terms)" "(assert '(?x (Isa ?x Apple)))" "(list-terms)" "(defineTerm '(?x (Isa ?x Apple)))" "(list-terms)" "(clearkb true)" "(defineTerm '(?x (Isa ?x Apple)))" "(list-terms)" "(defineTerm '(Isa x y))" "(csneps.test.benchmark/benchmark)" "(filter \#(not (ct/asserted? % (ct/currentContext))) @csneps/TERMS)" "(filter \#(not (ct/asserted? % (ct/currentContext))) (vals @csneps/TERMS))" "(csneps.test.benchmark/benchmark)" "(filter \#(not (ct/asserted? % (ct/currentContext))) (vals @csneps/TERMS))" "(csneps.test.benchmark/benchmark)" "(filter \#(not (ct/asserted? % (ct/currentContext))) (vals @csneps/TERMS))" "(find-term 'ant68503)" "(\:i-channels (find-term 'ant68503))" "(\:in-channels (find-term 'ant68503))" "(\:ant-in-channels (find-term 'ant68503))" "(\:ruis (find-term 'wft491))" "(\:i-channels (find-term 'ant69084))" "(\:ruis (find-term 'wft491))" "(csneps.test.benchmark/benchmark)" "(clearkb true)" "(defineTerm '(?x (Isa ?x Entity)))" "(defineTerm '(?x (?y (Isa ?x ?y)))" "(defineTerm '(?x (?y (Isa ?x ?y))))" "(startGUI)"]
eclipse.preferences.version=1
